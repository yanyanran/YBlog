## GC机制

#### 三色标记法

- 白色对象：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

起初所有的对象都是白色的。从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；重复直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象。



#### 其他方法

1、**引用计数法**：根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。

- 优点：简单直接，回收速度快
- 缺点：需要额外的空间存放计数，无法处理循环引用的情况；

2、**标记清除法**：标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象

- 优点：简单直接，速度快，适合可回收对象不多的场景
- 缺点：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配；

3、**复制法**：将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理

- 优点：解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；
- 缺点：有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；

4、**标记整理**：标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容

- 优点：解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用；
- 缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成；



#### go使用三色标记法的原因

- 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但go运行时的分配算法基于`tcmalloc`，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于`tcmalloc`的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
- 分代`GC`依赖分代假设，即`GC`将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。
- Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代`GC`回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当`goroutine`死亡后栈也会被直接回收，不需要`GC`的参与，进而分代假设并没有带来直接优势。
- Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。



#### GC 的触发时机

系统触发和主动触发。

- gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时

- gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。时间周期以runtime.forcegcperiod 变量为准，默认 2 分钟

- gcTriggerCycle：如果没有开启 GC，则启动 GC

- 手动触发的 runtime.GC 方法



#### 为什么Go的GC还是老旧的标记清除而不是和java一样使用分代算法

Go的逃逸分析会把大部分新生对象放在栈上，而GC是针对堆的，分代效果不大。

标记清除算法可以在垃圾回收过程中并发执行，不用STW