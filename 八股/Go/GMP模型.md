## GMP模型

- G：**Goroutine**，是一个轻量级的执行单元，可以在用户态进行切换和调度。每个goroutine都有自己独立的堆栈和寄存器等信息
- M：**操作系统线程**，实际的执行单元，负责将 goroutine 调度到逻辑处理器上执行。Go 程序中通常会创建多个 M，以便在多核 CPU 上实现并发执行
- P：**调度器CPU**，一个虚拟的执行单元，进程调度的关键，维护了一个可运行的协程队列和一些运行时的信息。Go程序中有多个P，每个P可以运行多个goroutine，因此可以实现真正的并发执行



#### 关于 G,P,M 的个数问题

G的个数理论上是无限制的，但受内存限制

P的数量一般建议是逻辑 CPU 数的 2 倍

M的数据默认启动时是10000，但内核很难支持这么多线程数，M一般要大于P



#### GMP调度流程

1、每个P都有一个本地队列存放等待运行的G，每个P最多可以同时绑定一个M和一个G

2、当一个M上的G执行完毕或被阻塞时，M会从P的本地队列或全局队列中取一个新的G来执行；如果队列为空，则会从其他P的本地队列中**偷一半**的G

3、当一个M上没有可运行的G时，M会释放绑定的P，并加入到空闲M列表中，等待被唤醒

4、当系统中有新的G被创建时，它会优先加到当前M绑定的P的**本地队列**中，队列已满则会把一半的G转移到**全局队列**中

5、当系统中有新的事件发生时（网络I/O、系统调用、信号处理），会创一个特殊的G来处理，并唤醒一个空闲M或创一个新的M来执行这个G



#### 抢占式调度

1. **系统调用和函数调用边界**：Go 语言的调度器会在系统调用或者特定的函数调用边界进行抢占。当 goroutine 执行系统调用或者函数调用时，调度器会检查是否有其他 goroutine 等待执行，并决定是否将当前 goroutine 暂停，切换到其他可执行的 goroutine 上。
2. **抢占点**：Go 语言的编译器会在一些代码位置插入抢占点。抢占点是指在这些位置上，编译器会插入代码来检查是否需要进行 goroutine 的切换。抢占点通常包括函数调用、循环等代码块的入口处。
3. **时间片**：每个 goroutine 在执行时会被分配一个时间片，时间片用完后，调度器会暂停当前 goroutine，并切换到其他等待执行的 goroutine 上。这种方式可以确保每个 goroutine 都能够获得公平的执行机会。

抢占式调度**并不是真正的硬件级别的抢占**，而是在 goroutine 主动放弃执行权或者在抢占点进行切换。这种协作抢占的方式相对于硬件级别的抢占更加轻量和高效，避免了线程切换的开销



#### 

#### M0

（跟进程数量绑定，一比一）：

- 启动程序后`编号为0`的主线程
- 在全局变量`runtime.m0`中，不需要在`heap`上分配
- 负责执行初始化操作和`启动第一个G`
- 启动第一个G之后，`M0就和其他的M一样了`

#### G0

（每个M都会有一个G0）：

- 每次`启动一个M`，都会`第一个创建的gourtine`，就是`G0`
- G0仅用于`负责调度G`
- G0不指向任何`可执行的函数`
- 每个M都会有一个自己的G0
- 在调度或系统调用时会使用M切换到G0，再通过G0进行调度

**M0和G0都放在全局空间**



#### 调度器的生命周期

1. runtime创建最初的线程m0和goroutine g0，并把2者关联。
2. 调度器初始化：初始化**m0、栈、垃圾回收**，以及创建和初始化由**GOMAXPROCS**个`P`构成的`P列表`。
3. 示例代码中的main函数是`main.main`，`runtime`中也有1个main函数——`runtime.main`，代码经过编译后，`runtime.main`会调用`main.main`，程序启动时会为`runtime.main`创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。
4. 启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。
5. G拥有栈，M根据G中的栈信息和调度信息设置运行环境
6. M运行G
7. G退出，再次回到M获取可运行的G，这样重复下去，直到`main.main`退出，`runtime.main`执行Defer和Panic处理，或调用`runtime.exit`退出程序。