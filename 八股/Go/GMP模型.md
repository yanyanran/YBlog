## GMP模型

- G: **Goroutine 执行的上下文环境**，每个 goroutine 都有自己独立的堆栈和寄存器等信息
- M: **操作系统线程**。实际的执行单元，负责将 goroutine 调度到逻辑处理器上执行。Go 程序中通常会创建多个 M，以便在多核 CPU 上实现并发执行。
- P: **调度器CPU**，进程调度的关键。一个虚拟的执行单元，负责调度 goroutine 和执行 Go 代码。Go 程序中有多个 P，每个 P 可以运行多个 goroutine，因此可以实现真正的并发执行。



#### GMP调度流程

抢占式协作调度：

1. 主线程启动，在主线程中创建一个操作系统线程（M）和一个逻辑处理器（P）。
2. 当有 goroutine 函数被调用时，它会被放入到一个全局队列中等待执行。
3. P 从全局队列中获取任务并执行。如果 P 执行的 goroutine 阻塞（例如在等待 I/O 完成），则该 P 的所有 goroutine 都会被暂停，P 会将自己标记为阻塞状态并开始寻找其他可用的 P。
4. 如果没有可用的 P，则 M 变为自由线程，并且会去创建一个新的 P，以便执行未完成的 goroutine。新的 P 将加入到一个全局 P 列表中，而 M 将继续尝试在列表中寻找可用的 P。
5. 当 goroutine 阻塞时，Goroutine 在堆上分配一块内存来保存其状态，并被添加到相关的等待队列中。而主线程会进入休眠状态，等待唤醒事件发生。
6. 当阻塞的 goroutine 可以继续执行时，调度器会将它从等待队列中移除，并将其重新添加到全局队列中，等待 P 来执行。
7. 当程序结束时，所有未完成的 goroutine 都会被杀死，而 P 和 M 也会被回收。