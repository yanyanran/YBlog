## Slice

##### slice底层实现

- `array`: 指向底层数组的指针，占 8byte
- `len`: 切片长度，占 8byte
- `cap`: 切片容量，`cap` >= `len` ，占 8byte

##### slice扩容机制

用append对slice扩容，返回一个新slice。slice扩容取决于slice的元素类型和原始cap：

- `新扩容cap>当前cap的两倍` 则按新扩容cap分配
- `当前cap<256`则按当前cap的两倍分配
- `当前cap>=256`会进入一个循环，每次循环增加 (当前cap+3*256)/4 的cap，意味着从2倍扩容到1.25倍扩容的平滑过渡，如果循环中发生整数溢出则将扩容后的cap置为期望cap
- `初始cap=0`则按目标cap分配

slice扩容操作还会考虑内存对齐和池化技术以**提高内存访问效率和减少内存碎片**

##### silce内存对齐和池化技术

根据元素类型和新扩容容量计算出所需内存大小，根据内存对齐规则调整内存大小，使其能够被8或16整除，根据内存池技术从不同大小的内存块中分配合适的内存空间，根据实际分配的内存空间计算出最终的切片容量。

##### slice深拷贝和浅拷贝

**浅拷贝**（默认的赋值操作）：复制对象时只复制对象本身和其中包含的基本类型数据，不复制对象所引用的其他对象。也就是说在浅拷贝中，复制出的新对象与原对象共享同一些引用对象（如果改了其中一个对象中的引用对象，另一个对象也会改变）

**深拷贝**（copy函数、遍历slice再赋值）：复制对象时除了复制对象本身和其中包含的基本类型数据外，还会**递归复制**对象所引用的其他对象。也就是说在深拷贝中，复制出的新对象和原对象完全独立没有任何引用关系（修改其中一个对象中的引用对象，另一个对象不会受影响）

##### append如何保证并发安全

append不是并发安全的，需要使用channel或sync.Mutex。用sync.Mutex比较简单但会增加锁的开销和竞争；用不同切片来存不同goroutine产生的结果并在最后合并到一个切片中，比较复杂但可以减少锁的使用和冲突。
