## Map

#### map底层原理

底层结构是**hmap**，hmap里维护着多个**bucket数组**，数组中每个元素都是**bmap结构**（哈希值的高8位、溢出桶指针overflow），每个桶(bucket)存8个kv，如果8个满了又来一个key落在桶里，会用overflow连接下一个桶(溢出桶)

```go
type hmap struct {
    count     int     // 哈希表元素个数，调 len(map) 时返回的就是该字段值
    flags     uint8   // 状态标志（是否处于正在写入的状态等）
    B         uint8   // buckets对数。如果B=5则buckets数组长度=2^B=32，意味着有32个桶
    noverflow uint16  // 溢出桶数量
    hash0     uint32  // 生成hash的随机数种子
	buckets    unsafe.Pointer // 指向buckets数组的指针
	// 如果发生扩容，oldbuckets是指向老buckets数组的指针，老buckets数组大小是新buckets的1/2
	// 非扩容状态下，它为nil
	oldbuckets unsafe.Pointer
	nevacuate  uintptr  // 扩容进度，小于此地址的buckets代表已搬迁完成（用uintptr是为了避免被GC扫到）
	extra *mapextra // 存额外信息
}
```



#### map哈希冲突

**链地址法**，不过链表单元不是一个元素而是桶。每个哈希桶可以存8个元素，如果超过了8个则会链接到一个溢出桶中。溢出桶也可以链接到其他溢出桶中，形成一个链表。



#### map扩容

使用**渐进式扩容**，原有key不会一次性搬完，每次最多只搬2个bucket。只有在插入修改删除key时尝试进行搬迁buckets工作，会先检查 oldbuckets 是否搬迁完毕（是否为nil）

***等量扩容***：元素会重排但不会换桶。实际上是一种整理（map不断put和delete key导致桶中可能会出现很多断断续续的空位），把后置位的数据整理到前面。

***2倍扩容***：由于当前桶数组确实不够用了，元素会重排也可能会发生桶迁移

在hmap结构中有一个**oldbuckets**，扩容刚发生时会先将老数据存到里面。每次对map进行删改操作时，会触发从oldbucket中迁移到bucket的操作【非一次性，分多次】。在扩容没完全迁移完成前，每次get或put遍历数据时都会先遍历oldbuckets然后再遍历buckets。

##### map扩容条件

有个装载因子=map中元素个数/map中当前桶个数，指的是当前map中每个桶的平均元素个数。

1、**装载因子>6.5**（触发翻倍扩容），正常情况下如果没有溢出桶，一个桶中最多有8个元素，当平均每个桶中数据超过了6.5个，意味着当前容量要不足了

2、**溢出桶的数量过多**，导致溢出桶链条越长。当map操作数据时扫描速度会变慢（触发等量扩容）



#### map如何保证并发安全

map本身不是线程安全的，可使用读写锁`sync.RWMutex`，或者是直接使用支持并发读写map： `sync.Map`（空间换时间，减少加锁对性能的影响，适合读多写少），sync.Map主要由两个map组成：一个用于读一个用于写，这样可以减少锁的竞争。提供的方法：Store存储、Load获取值、Delete

**sync.Map缺点**：不能获取当前元素个数，也不能清空所有元素；占内存比较大；写操作多于读操作时性能不如map+锁



#### map无序遍历

使用快速随机算法随机选一个桶作为起始桶，且又快速随机选择桶内任意一个偏移元素作为起始元素。map因扩张⽽重新哈希时，各键值项存储位置都可能会发生改变，顺序没法保证，所以官方避免大家依赖顺序就直接打乱处理，就是for range map在开始处理循环逻辑时就做了**随机播种**



#### map插入时间、空间复杂度

> 取决于：
>
> - Map**元素类型**：不同类型元素可能占用不同大小的内存空间，影响Map的存储效率和哈希计算效率
> - Map**元素数量、负载因子**：元素数量/负载因子越多，可能导致哈希冲突越多，影响Map的查找和插入效率
> - Map**扩容策略**：当Map中元素数量超一定阈值时Map会扩容，重新分一个更大的哈希桶数组并将原来的元素复制到新数组中。扩容操作会消耗额外的时间和空间，但可以降低负载因子，提高Map的查找和插入效率
>
> - Map**创建时可以指定一个预期大小**（hint），可提高Map的空间利用率和插入效率，默认为0

时间复杂度O(1)，空间复杂度O(n)，n为元素数量；最坏时间复杂度O(n)，空间复杂度O(n)：

- 所有元素都映射到同个哈希桶中导致链表过长
- Map扩容时需要复制所有元素到新数组
- Map使用了非常大或非常小的预期大小（hint）导致空间浪费或频繁扩容



#### 删除一个key内存会被释放吗

具体和GC相关。如果删除的元素是**值类型**，如int，float，bool，string以及数组和struct，map内存不会自动释放；如果删除的元素是**引用类型**，如指针，slice，map，chan等，map内存会自动释放。

将map设置为nil后，内存被回收。