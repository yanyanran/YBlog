#### redis常见数据结构

1、**String**

- 缓存对象（直接缓存整个对象的JSON、采用将key进行分离为user:ID）、常规计数（原子性）、分布式锁、共享session信息
- SDS（简单动态字符串），SDS不仅可以保存文本数据还可以保存二进制数据，拼接字符串不会造成缓冲区溢出，空间不够会自动扩容

2、**List**

- 消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）
- 之前是由双向链表或压缩列表实现，列表元素个数小于512个且列表每个元素值都小于64字节时用压缩列表，否则用双向列表；后来3.2版本后redis用快表实现

#### 快表

压缩列表的不足：虽然通过紧凑型内存布局节省了内存开销，但如果保存的元素数量增加或者元素变大了，压缩列表会有「连锁更新」风险，一旦发生会造成性能下降。快表通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能

3、**Hash**

- 缓存对象、购物车
- 列表元素个数小于512个且列表每个元素值都小于64字节时用压缩列表，否则用哈希表；后面用listpack

4、**Set**

- 聚合计算（并集、交集、差集）场景：点赞、共同关注、抽奖活动
- 元素都是整数且元素个数小于512则用整数集合，否则用哈希表

5、**Zset**

相比于 Set 类型多了一个排序属性 score

- 排序场景：排行榜、电话和姓名排序
- 列表元素个数小于512个且列表每个元素值都小于64字节时用压缩列表，不满足就用跳表。后面用listpack

#### 跳表

跳表（O(logN)）是在链表（O(N)）基础上改进过来的，实现了一种多层的有序链表。