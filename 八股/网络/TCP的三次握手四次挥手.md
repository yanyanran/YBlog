## TCP的三次握手四次挥手

#### TCP报头格式

1、***源端口号和目标端口号***

2、***包的序号***：解决包乱序问题

3、***确认号***：确认发出去后对方是否有收到，为了解决丢包问题

4、***一些状态位***：SYN发起连接，ACK回复，RST重连，FIN结束连接

5、***窗口大小***：TCP做流量控制和拥塞控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。



#### TCP三次握手

- 一开始，client和server都处于 `CLOSED` 状态。先是server主动监听某个端口，处于 `LISTEN` 状态。
- 第一次握手：建立连接时，客户端发送SYN（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。
- 第二次握手：服务器收到后确认客户端的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即**SYN+ACK**包，此时服务器进入SYN_RECV状态
- 第三次握手：客户端收到包向服务器发送ACK（ACK=k+1），此包发送完毕，客户端和服务器进入established建立连接状态，完成三次握手。

> **目的**：保证双方都有发送和接收的能力
>
> **查看TCP连接状态**：netstat -napt命令



> **TCP三次握手可以变成两次吗？**
>
> **长话**：TCP为了实现可靠数据传输， 双方都必须维护一个序列号去标识发送出去的数据包中， 哪些是已经被对方收到的。 而三次握手就是相互告知序列号起始值， 并确认对方已经收到了序列号起始值。
> 如果只是两次握手， 最多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。
>
> **短说**：tcp通信需要确保双方都具有数据收发的能力，得到ACK响应则认为对方具有数据收发的能力，因此双方都要发送SYN确保对方具有通信的能力。



#### TCP四次挥手

- 客户端发送一个**FIN**，用来关闭客户端到服务器的数据传送
- 服务器收到后返回一个**ACK**，序号为收到的FIN+1。和SYN一样，一个FIN将占用一个序号。
- 服务器关闭与客户端的连接，发送一个**FIN**给客户端。
- 客户端发回ACK报文确认，并将ACK设为收到的FIN序号加1。



> **四次挥手可以压缩成三次吗？**（服务端的ACK和FIN是否能合并）
>
> 服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但**服务端可能还有数据要发送或者处理，所以并不能马上发送 FIN 报文**，而是将发送 FIN 报文的控制权交给服务端，所以服务端的 ACK 和 FIN 一般都分开发送。
>
> 

> **TCP半关闭状态**
>
> 在TCP连接中，一端发送了FIN分节，表示不再发送数据，但仍然可以接收对端发送的数据，此时这一端就进入了半关闭状态。



#### TCP分割数据

如果HTTP请求消息超过了MSS长度1460bytes（MTU一个包的最大长度1500bytes - IP和TCP头）