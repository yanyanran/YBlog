## 锁

#### MySQL锁

1、**全局锁**：

- 开启：flush tables with read lock，执行后数据库只读
- 释放：unlock tables
- 应用场景：做全库备份
- 缺点：数据量大会花费时间；备份期间业务只能读而不能更新，造成业务停滞
- 改进：InnoDB可重复读隔离级别。在备份数据库前先开启事务，创建Read View，然后整个事务执行期间都用这个Read View，而且由于MVCC的支持，备份期间业务依然可以对数据进行更新操作

2、**表级锁**：

- **表锁**：开启lock tables t_student read/write，表锁除了会限制别的线程读写外，也会限制本线程接下来的读写操作（InnoDB实现了行级锁）

- **元数据锁（MDL）**：为保证当用户对表执行CRUD操作时，防止其他线程对这个表结构做变更：对一张表进行 CRUD 操作时加的是读锁；做结构变更操作时加的是写锁。在事务提交后释放。

  申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，会阻塞后续该表的所有 CRUD 操作。所以为能安全对表结构进行变更，在变更前先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill掉这个长事务，然后再做表结构的变更

- **意向锁**：目的是为了快速判断表里是否有记录被加锁。InnoDB表里对某些记录加「共享读锁」前需要先在表级加一个「意向共享锁」；对某些记录加「独占写锁」之前，需要先在表级别加上一个「意向独占锁」

  意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只和共享表锁（\*lock tables ... read\*）和独占表锁（\*lock tables ... write\*）发生冲突（表锁和行锁满足读读共享、读写互斥、写写互斥）

- **AUTO-INC 锁**：给自增ID加的轻量级锁，给字段赋一个自增值后就把这个锁释放，而不需要等待整个插入语句执行完后才释放

3、**行锁**：InnoDB引擎支持行级锁，MyISAM引擎不支持

- **记录锁**：仅把一条记录锁上
- **间隙锁**：锁一个区间但不包含记录本身（目的：解决可重复读隔离级别下幻读现象）
- **Next-Key锁**：锁定一个范围且锁定记录本身
- **插入意向锁**：不是意向锁而是一种特殊间隙锁，属行锁。一个事务在插入一条记录时，需判断插入位置是否被其他事务加了间隙锁（next-key锁也包含间隙锁）。有的话插入操作就会阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录但现在处于等待状态



## MySQL死锁

#### 死锁条件

互斥、占有且等待、不可强占用、循环等待

#### 如何解决死锁问题

通过「打破循环等待条件」来解除死锁状态

1、设置事务等待锁的超时时间。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放，另一个事务就可以继续执行了

2、开启主动死锁检测。主动死锁检测在发现死锁后会主动回滚死锁链条中的某一个事务，让其他事务继续执行

