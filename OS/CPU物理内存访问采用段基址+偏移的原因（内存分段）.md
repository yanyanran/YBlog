## CPU物理内存访问采用`段基址+偏移`的原因（内存分段）

这个问题的主要原因还是来源于**内存访问（程序）的分段问题**

那为什么要分段访问呢？



### 1、程序重定位

在之前使用的`硬编码`模式下，CPU直接访问物理内存，CPU上运行的程序中的指令地址也必须是绝对物理地址。此时程序放在内存中固定的地方写死，出现的弊端就是：两个编译出来地址相同的程序不能同时运行，只能运行一个，程序无法重定位。

此时**使用段基址+段内偏移就可以让程序*重定位***了，也就是将程序指令地址改成另一个地址，但地址处的内容还是原来的内容。

#### 就好比0xC00:3和0xC02:1访问到的物理内存是同一块地。

也就是只要分了段，无论把整个段的位置平移到哪，**段内的地址相对于段基址都是不变的**。无论段基址是多少，只要给出段内偏移，**根据段+偏移产生的逻辑地址就可以让CPU访问到实际物理地址中的正确命令**。



### 2、扩大寄存器用址范围

CPU有20条地址总线，能表示的最大内存即：2^20（0xfffff）。

寄存器仅有16位，最大存放地址的大小为：2^16（0xffff）。

显然寄存器能表示的最大内存地址不够CPU的最大上限。为了能**让cpu寄存器将0xfffff的地址保存全，扩大寄存器访问内存大小**，于是采用`段地址+段内偏移地址`的形式访问内存。

这样我们就可以用`0xf000:0xffff` -> 基地址*16+偏移=0xfffff来访问到最大地址了。然后CPU会将这两个地址相加后的结果用于内存访问，送上地址总线。





再者就能基于分段引出**平坦模型**的概念：

虽然从CPU内存的宏观角度来看会有多个类似于滑动窗口一样的“段”，但针对一个段内的寻址而言我们不需要去关注“段”，因为段就是自身，段内是平坦的，这是一个相对的概念。