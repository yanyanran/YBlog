## 记一次对`call near/jmp short的操作数为相对立即数`的思考

### Q：

对于指令jmp和call，jmp有短转移【jmp short】，call有近调用【call near】。

二者有个共同点就是它们的**操作数**最后经过编译都变成了**相对增量立即数**，**但CPU最终还是需要将这个立即数转成绝对地址才能执行**。那么为什么操作数里面不直接存绝对地址呢？

存个相对立即数CPU还得转换一下感觉有点多此一举。要说分远近call（near/far）还能理解，near在同一段内只需要压ip入内存栈，而far需要压cs和ip。但是立即数这个转换有什么必要？



### A：

（问了微机原理老师）

问题是你不知道操作系统把你的代码放到哪里去了，咱只能给出相对增量，得等到操作系统把程序放到内存中才能确定其绝对地址。

操作系统每次执行程序时分配的内存位置地址都不一样，所以你不能给出绝对地址只能给出相对地址。

8085体系结构是单进程64k，所以都是绝对地址；而8086为多进程体系，只有给每个进程分配了cs、ds、ss，绝对地址才能确定。背后其实是多进程体系结构的思想。



体现了之前对绝对地址的认知误区。这和CPU内的段设计能联系起来，对于内存中的分配使用情况我们是不知道不确定的，每次运行程序的内存使用情况都不一样，所以只能给出相对偏移地址。