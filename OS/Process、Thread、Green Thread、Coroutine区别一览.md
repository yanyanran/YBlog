## Process、Thread、Green Thread、Coroutine区别一览



#### 进程Process

正在运行的程序的一个实例

=> 资源分配的基本单位。每个进程都有自己的地址空间，包括代码段、数据段和堆栈段。



#### 线程Thread

进程中的一个实体，系统调度的基本单位

=> 共享所属进程中的全部系统资源（vaddr、文件描述符、信号处理），但每个线程有自己的调用栈、寄存器环境和本地存储



#### 绿色线程Green Thread

Green Thread不是操作系统级别的概念，它是**用户层（语言级别）**实现的线程 

=> 当一个Green Thread使用系统调用被阻塞时，os不会帮助调度其他线程 -> 导致该进程内所有线程被阻塞

=> ***保存完整的上下文***，开销较大（一般由VM实现）

=> 绿色线程会被匹配到一个原生线程池，从原生线程池中获取原生线程来执行绿色线程。有时候是 1 个原生线程执行 m 个绿色线程（这时候和早期没什么区别）；有时候是 n 个原生线程执行 m 个绿色线程——这时候的绿色线程就获得了**并行**能力。



#### 协程Coroutine

一种比线程更小的执行单元，同样是**用户层**实现的线程。

=> 自带CPU上下文 -> 可任意切换到别的coroutine

=> 与线程相比，coroutine切换**不需要os进行保存和恢复CPU上下文**（因为所有coroutine都存在于同个线程中，所以coroutine切换只有单纯的CPU上下文切换 => 开销小）

=> 调度方式为**非抢占式**（上面三个都是抢占式的） -> 只有当前coroutine主动让出CPU，调度器才会从协程池中调用下一个coroutine

=> 大多数coroutine***不保存完整的上下文***

=> 协程不能并行，只能**并发**





> **并发**针对单核 CPU 而言，它指的是 CPU 交替执行不同任务的能力；
>
> **并行**针对多核 CPU 而言，它指的是多个核心同时执行多个任务的能力。

