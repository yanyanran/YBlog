### 为什么有寄存器？

CPU只负责运算而不负责存储数据。

如果数据存在内存中，CPU去内存读写数据的速度会远慢于CPU本身的运行速度。为不被拖慢速度，CPU设了**一级缓存和二级缓存**。但CPU缓存还不够快（缓存地址不固定，CPU寻址拖速度），所以CPU还自带了**寄存器**，一个CPU内部有多个寄存器来存常用的数据。

寄存器*[0级缓存]*不靠地址**区分数据**，而是**靠名字**（每个寄存器都有自己的名字）



------

### x86 -- 8086寄存器

8086中共有`14个`16位的寄存器

#### **1、通用寄存器**

##### （1）数据寄存器

> ​	AX ：累加寄存器；【AH、AL】
>
> ​	BX ：基地址寄存器；【BH、BL】
>
> ​	CX ：计数器寄存器；【CH、CL】
>
> ​	DX：数据寄存器；【DH、DL】

8086之前的是8位CPU，所以为兼容之前的8位程序，8086中每个数据寄存器都**可以当作两个单独的寄存器使用**（16-> 8*2）【Hight(H)和Low(L)】



##### （2）变址寄存器

> ​	SI：源变址寄存器；
>
> ​	DI ：目的变址寄存器；



##### （3）指针寄存器

> ​	BP ：基指针寄存器，结合SS一起使用（**SS:bp**）可以把栈作为普通数据段通过偏移量自由访问；	
>
> ​	SP：堆栈指针寄存器，（**SS:sp**）**指向栈顶**【必须和 SS 段寄存器一起使用】

【`BP和SS`】

如果在指令中**没有明确或显示给出段地址时, 段地址使用默认的 SS 寄存器中的值(BX，SI，DI 会默认使用 DS 段寄存器)** => DS:[BP]为段地址为DS偏移地址为BP的内存单元；[BP]为段地址为SS偏移地址为BP的内存单元。

【`SP和SS`】

指向的是内存栈的**栈顶**元素。当使用 PUSH 指令向栈中压入 1 个字节单元时，SP =SP - 1；当使用 POP 指令从栈中弹出 1 个字节单元时， SP =SP + 1。



> #### 堆栈框架的创建步骤（32位下）:
>
> （1）传递参数从右往左的先后顺序压入堆栈；
>
> （2）子例程被调用，子例程的返回地址压入堆栈
>
> （3）子例程开始执行时，EBP被压入堆栈
>
> （4）EBP设为ESP的值，ESP减去一个数值，EBP就被作为寻址所有子例程参数的基址指针使用了
>
> （5）如果有局部变量，ESP减去一个数值，以便在多站上为局部变量保存空间
>
> （6）如果任何寄存器需要保存，则压入堆栈



#### 2、控制寄存器

> ​	IP：指令指针寄存器；
>
> ​	FLAG：标志寄存器；

#### 3、段寄存器

因为段寄存器中存放的是内存地址，所以不能用立即数赋值。

> ​	CS：代码段寄存器；
>
> ​	DS：数据段寄存器；
>
> ​	SS ：堆栈段寄存器；
>
> ​	ES ：附加段寄存器；



------

### 伪指令

伪指令在汇编程序编译时就执行，而指令在编译时仅转为机器码，后续执行交给CPU。所以在写汇编**使用伪指令时需要jmp**，因为就算是伪指令也占地址，**jmp防止CPU将其当做指令而执行出错**。



`db`：字节定义。一个字节数据占1个字节单元，读完一个偏移量加1

`dw`：定义字类型变量，一个字数据占2个字节单元，读完一个偏移量加2

`dd`：定义**双字类型**变量，一个双字数据占**4**个字节单元，读完一个偏移量加4

`ds`：定义存储空间指令。（e.g. ds5 db 50H -> 汇编后，从0090H开始保留5个存储单元，而（0095H）=50H）

`EQU`：赋值指令。格式：【字符名称   EQU  数或特定的符号】

`ORG`：实现规定程序的起始地址。如果没有ORG则程序执行时指令代码被放到自由内存空间的CS:0处；若有ORG伪指令，编译器则把其后的指令代码放到ORG伪指令指定的偏移地址。

`times`：nasm伪指令，相当于循环来重复执行times后面的表达式（非CPU执行而是nasm执行）

------

### 两种内存模型

但寄存器只能放少量数据，大多数情况CPU需要指挥寄存器直接**和内存交换数据**

#### **1**、内存数据模型Heap ->  

由用户**主动请求**内存（new或malloc）而划分出来的内存区域。

必须手动释放或通过垃圾回收机制来回收。

#### 2、内存数据模型Stack ->  

除了Heap其他的内存占用为Stack，它是由函数运行而**临时占**的内存区域，Stack中包含以**帧**为单位的概念。



```clike
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
```

```clike
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:  // 在Stack上为main建立一个帧，并将Stack指向的地址写入esp寄存器
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
```

main中首先执行了push 3。

### push

push指令有个前置操作：先取出esp寄存器地址-4字节，然后把新地址写入esp寄存器。

**减操作**因为Stack从高到低发展，-4是因为3的类型是int（占4个字节）。得到新地址之后3就会写入这个地址开始的四个字节。

### call

call操作就是调用函数，同时为这个函数建立一个新的帧。

### push

push操作表示将ebx寄存器里的值写入_add_a_and_b这个帧中。

### mov

mov指令将一个值写入某个寄存器当中（mov a,b -> b写入a中）。_add_a_and_b中的第二行mov操作表示先把esp寄存器里的地址+8个字节得到一个新地址，然后按照这个地址在Stack中取出数据。然后根据前面可以推算出从这里取出来的是2，然后把2再写入eax寄存器当中。

### int n

int用来引发中断，n表示中断号。执行int n时:

1、CPU先从中断向量表中找到n号表项

2、标志寄存器入栈（pushf），IF=0，TF=0（重置中断标志位）

3、接着cs、ip入栈，修改cs和ip【` (IP)=(n*4)，(CS)=(n*4+2)`】

### in .., dx

从端口读取数据。

> （这里说的端口和网络端口不是一个东西，os端口是**IO接口开放给CPU的接口，也就是IO接口中的寄存器**）

左边是目标操作数【al/ax】，右边是源操作数（源操作数【端口号】必须是dx）

### out dx/立即数, al/ax

往端口写数据

### inc

指定操作数+1

### shl

操作数左移一位

### xor

异或



## 跳转指令

一、无条件跳转

```
JMP  ;无条件跳转
```


二、根据CX、ECX寄存器的值跳转

```
JCXZ  ;CX 为 0 则跳转
JECXZ ;ECX 为 0 则跳转
```


三、根据标志位跳转的指令

```
JE   ;等于则跳转	     		同JZ
JNE  ;不等于则跳转	       同JNZ
```

```
JA   ;无符号大于则跳转
JNA  ;无符号不大于则跳转
JAE  ;无符号大于等于则跳转	 同JNB
JNAE ;无符号不大于等于则跳转	同JB
```

```
JB   ;无符号小于则跳转
JNB  ;无符号不小于则跳转
JBE  ;无符号小于等于则跳转	 同JNA
JNBE ;无符号不小于等于则跳转	同JA
```

```
JG   ;有符号大于则跳转
JNG  ;有符号不大于则跳转
JGE  ;有符号大于等于则跳转	 同JNL
JNGE ;有符号不大于等于则跳转	同JL
```

```
JL   ;有符号小于则跳转
JNL  ;有符号不小于则跳转
JLE  ;有符号小于等于则跳转	 同JNG
JNLE ;有符号不小于等于则跳转	同JG
```

```
JZ   ;为零则跳转
JNZ  ;不为零则跳转

JS   ;为负则跳转
JNS  ;不为负则跳转

JC   ;进位则跳转
JNC  ;不进位则跳转

JO   ;溢出则跳转
JNO  ;不溢出则跳转
```

```
JP;为偶则跳转
JNP  ;不为偶则跳转
JPE  ;奇偶位置位则跳转		同JP
JPO  ;奇偶位复位则跳转		同JNP
```

![](https://github.com/yanyanran/pictures/blob/main/%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.png?raw=true)