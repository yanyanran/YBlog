### 为什么有寄存器？

CPU只负责运算而不负责存储数据。

如果数据存在内存中，CPU去内存读写数据的速度会远慢于CPU本身的运行速度。为不被拖慢速度，CPU设了**一级缓存和二级缓存**。但CPU缓存还不够快（缓存地址不固定，CPU寻址拖速度），所以CPU还自带了**寄存器**，一个CPU内部有多个寄存器来存常用的数据。

寄存器*[0级缓存]*不靠地址**区分数据**，而是**靠名字**（每个寄存器都有自己的名字）



------

### x86 -- 8086寄存器

8086中共有`14个`16位的寄存器

#### **1、通用寄存器**

##### （1）数据寄存器

> ​	AX ：累加寄存器；【AH、AL】
>
> ​	BX ：基地址寄存器；【BH、BL】
>
> ​	CX ：计数器寄存器；【CH、CL】
>
> ​	DX：数据寄存器；【DH、DL】

8086之前的是8位CPU，所以为兼容之前的8位程序，8086中每个数据寄存器都**可以当作两个单独的寄存器使用**（16-> 8*2）【Hight(H)和Low(L)】



##### （2）指针寄存器

> ​	BP ：基指针寄存器；	
>
> ​	SP：堆栈指针寄存器；【必须和 SS 段寄存器一起使用】

【`BP`】如果在指令中**没有明确或显示给出段地址时, 段地址使用默认的 SS 寄存器中的值(BX，SI，DI 会默认使用 DS 段寄存器)** => DS:[BP]为段地址为DS偏移地址为BP的内存单元；[BP]为段地址为SS偏移地址为BP的内存单元。

【`SP和SS`】指向的是内存栈的**栈顶**元素。当使用 PUSH 指令向栈中压入 1 个字节单元时，SP =SP - 1；当使用 POP 指令从栈中弹出 1 个字节单元时， SP =SP + 1。



##### （3）变址寄存器

> ​	SI：源变址寄存器；
>
> ​	DI ：目的变址寄存器；

#### 2、控制寄存器

> ​	IP：指令指针寄存器；
>
> ​	FLAG：标志寄存器；

#### 3、段寄存器

不能用立即数赋值。

> ​	CS：代码段寄存器；
>
> ​	DS：数据段寄存器；
>
> ​	SS ：堆栈段寄存器；
>
> ​	ES ：附加段寄存器；



------

### 伪指令

伪指令在汇编程序编译时就执行，而指令在编译时仅转为机器码，后续执行交给CPU。所以在写汇编**使用伪指令时需要jmp**，因为就算是伪指令也占地址，**jmp防止CPU将其当做指令而执行出错**。



`db`：字节定义。一个字节数据占1个字节单元，读完一个偏移量加1

`dw`：定义字类型变量，一个字数据占2个字节单元，读完一个偏移量加2

`dd`：定义双字类型变量，一个双字数据占4个字节单元，读完一个偏移量加4

`ds`：定义存储空间指令。（e.g. ds5 db 50H -> 汇编后，从0090H开始保留5个存储单元，而（0095H）=50H）

`EQU`：赋值指令。格式：【字符名称   EQU  数或特定的符号】

`ORG`：实现规定程序的起始地址。如果没有ORG则程序执行时指令代码被放到自由内存空间的CS:0处；若有ORG伪指令，编译器则把其后的指令代码放到ORG伪指令指定的偏移地址。

------

### 两种内存模型

但寄存器只能放少量数据，大多数情况CPU需要指挥寄存器直接**和内存交换数据**

#### **1**、内存数据模型Heap ->  

由用户**主动请求**内存（new或malloc）而划分出来的内存区域。

必须手动释放或通过垃圾回收机制来回收。

#### 2、内存数据模型Stack ->  

除了Heap其他的内存占用为Stack，它是由函数运行而**临时占**的内存区域，Stack中包含以**帧**为单位的概念。



```clike
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
```

```clike
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:  // 在Stack上为main建立一个帧，并将Stack指向的地址写入esp寄存器
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
```

main中首先执行了push 3。

### push

push指令有个前置操作：先取出esp寄存器地址-4字节，然后把新地址写入esp寄存器。

**减操作**因为Stack从高到低发展，-4是因为3的类型是int（占4个字节）。得到新地址之后3就会写入这个地址开始的四个字节。

### call

call操作就是调用函数，同时为这个函数建立一个新的帧。

### push

push操作表示将ebx寄存器里的值写入_add_a_and_b这个帧中。

### mov

mov指令将一个值写入某个寄存器当中（mov a,b -> a写入b中）。_add_a_and_b中的第二行mov操作表示先把esp寄存器里的地址+8个字节得到一个新地址，然后按照这个地址在Stack中取出数据。然后根据前面可以推算出从这里取出来的是2，然后把2再写入eax寄存器当中。

### int n

int用来引发中断，n表示中断号。执行int n时:

1、CPU先从中断向量表中找到n号表项

2、标志寄存器入栈（pushf），IF=0，TF=0（重置中断标志位）

3、接着cs、ip入栈，修改cs和ip【` (IP)=(n*4)，(CS)=(n*4+2)`】