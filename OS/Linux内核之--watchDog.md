# Linux内核之 -- watchDog



Linux内核watchDog用于监视系统是否正在运行，可以自动重启挂起的系统。



#### 软锁定（Softlockup）检测器和硬锁定（Hardlockup）检测器

###### 1、软锁定Softlockup

导致**内核**在内核模式下循环超过**20s**而不给其他任务运行的机会的错误。

在检测到软锁定时，当前的堆栈跟踪会被显示出来，并且默认情况下系统会保持锁定状态。另外，内核可以配置为panic，提供了一个sysctl参数“kernel.softlockup_panic”，一个内核参数“softlockup_panic”，以及一个编译选项“BOOTPARAM_SOFTLOCKUP_PANIC”。



###### 2、硬锁定Hardlockup

导致**CPU**在内核模式下循环超过**10s**而不让其他中断有机会运行的错误。

与软锁定情况类似，检测到时会显示当前的堆栈跟踪，并且系统会保持锁定状态，除非更改默认行为，这可以通过sysctl参数“hardlockup_panic”，编译时选项“BOOTPARAM_HARDLOCKUP_PANIC”和内核参数“nmi_watchdog”来完成。



#### 实现

softlockup selecter和hardlockup selecter建立在**hrtimer和perf子系统**之上（这样就可以让软锁定和硬锁定检测器在任何存在这些子系统的体系结构中工作）。

> **hrtimer子系统**
>
> Linux内核中的高精度（纳秒级别）**定时器**子系统，它提供了一种用于创建、管理和触发高分辨率定时器的机制，可以在内核中被用于如*处理延迟、定时事件和周期性任务*等
>
> 它在`软锁定和硬锁定检测器`中被用于**生成中断并唤醒watchDog任务**
>
> **perf子系统**
>
> Linux内核的**性能事件**子系统，利用处理器提供的性能计数器和事件采样机制，能**监测和记录各种硬件和软件事件**：指令执行、缓存命中率、函数调用等
>
> 在`软锁定和硬锁定检测器`中用于**生成NMI（非屏蔽中断）事件，并作为`硬锁定检测器`的触发机制之一，以检测CPU的硬锁定情况**



1. 定期的hrtimer生成中断并唤醒watchDog任务（周期：2 * watchdog_thresh / 5=> 意味着hrtimer在硬锁定检测器启动之前有两到三次机会生成中断）
2. 每隔“watchdog_thresh”秒perf生成一个**NMI事件【-> 检查硬锁定】**
3. 如果系统中的任何CPU在此期间未收到任何hrtimer中断，即CPU无响应，则“硬锁定检测器”（NMI事件处理程序）将生成一个内核warning或调用panic（具体取决配置）

**watchDog任务【-> 检查软锁定】**是一个高优先级的内核线程，每次调度时会更新一个时间戳。如果该时间戳在2 * watchdog_thresh秒（软锁定阈值）内没有更新，则“软锁定检测器”（编码在hrtimer回调函数中）会将有用的调试信息转储到系统日志中，之后根据指令执行panic或恢复其他内核代码的执行。

> 硬锁定检测器和软锁定检测器是并行工作的，但硬锁定检测器的触发优先级高于软锁定检测器。
>
> 如果硬锁定被检测到，系统会立即采取行动。如果硬锁定未被检测到，而软锁定被检测到，则软锁定检测器会触发，并根据配置采取相应的操作。



如上所述，内核提供了一个内核选项，允许管理员配置hrtimer和perf事件的周期。对于特定环境来说选择合适的值是在**快速响应锁定**和**检测开销**之间进行权衡。





------





#### 内核公平调度任务（CFS）被高优先级任务(如RT任务)抢占后饿死场景监控

C,Linux

在实时调度与公平调度并存的产品业务场景，公平调度（CFS）任务可能会因为实时调度任务长时间占用CPU而得不到及时的调度，会导致正常用户业务将受到影响、且串口无法进行调测定位。本特性通过监测CFS进程的调度情况，当发现CFS进程调度饿死时，及时输出相关的调测信息，协助定位问题原因。



### 项目产出要求

- 1、输出合理的设计文档。

- 2、编码符合clean code 规范，模块独立，无侵入式修改。

- 3、模块功能满足项目要求，能对CFS进程被RT进程长时间抢占后的饿死情况进行检测监控,可以设置检测阈值，以及需要被检测的CPU。

- 4、模块运行资源消耗低，CPU占用率不高于1%



### 项目技术要求

- 1、熟悉linux 内核编程框架，基于openEuler 内核进行开发。

- 2、熟练掌握C语言

- 3、对linux调度子系统有一定的掌握，熟悉内核通用的进程异常检测机制。



https://gitee.com/openeuler/kernel

【相关参考资料】：
https://linuxhint.com/linux-kernel-watchdog-explained/
https://www.kernel.org/doc/Documentation/lockup-watchdogs.txt





------





### RT任务

RT任务是指实时任务（Real-Time Task），也称为硬实时任务。实时任务是在实时系统中运行的任务，具有严格的时间限制和响应要求。其特点是**必须在规定的时间内完成**，并且对任务响应时间有严格要求，因为任务的延迟可能导致系统性能下降、数据丢失、系统崩溃等严重后果。

实时任务通常可以分为两类：

1. 硬实时任务（Hard Real-Time Task）：这类任务要求必须在严格的时间限制内完成，任何延迟都是不可接受的。例如，航空航天、医疗设备等领域的实时系统通常包含硬实时任务。
2. 软实时任务（Soft Real-Time Task）：这类任务也有时间限制，但对于任务完成时间的要求相对宽松，可以接受一定的延迟。软实时任务通常是对响应时间有一定要求的应用，如多媒体流媒体、实时游戏等。

在实时系统中，通常会使用实时调度算法（如优先级调度算法）来对实时任务进行调度，确保高优先级的实时任务能够及时获得CPU资源，并满足其时间约束。这样可以保证实时任务的及时响应和系统的可靠性。

需要注意的是，RT任务与普通的一般计算任务不同，其对系统资源和时间的要求更为严格，因此在设计和开发实时任务时需要特别注意任务的响应时间、资源占用和调度策略等因素，以确保系统的实时性和可靠性。
